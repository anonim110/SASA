<!DOCTYPE html>
<html>
<head>
    <title>3D FPS NEON SHOOTER</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; cursor: none; }
        #ui { position: absolute; top: 10px; left: 10px; color: #0ff; font-weight: bold; pointer-events: none; z-index: 10; text-shadow: 0 0 5px #000; }
        /* Простой прицел в центре экрана */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 2px; height: 2px; background: #0f0; box-shadow: 0 0 10px #0f0; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 10; }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      { "imports": { "three": "https://unpkg.com/three@0.154.0/build/three.module.js" } }
    </script>
</head>
<body>
    <div id="ui">
        WASD - Move | MOUSE - Aim/Shoot<br>
        HP: <span id="hp">100</span> | Kills: <span id="score">0</span>
    </div>
    <div id="crosshair"></div>
    
    <script src="/socket.io/socket.io.js"></script>
    <script type="module">
        import * as THREE from 'three';

        const socket = io();

        // --- 1. СЦЕНА THREE.JS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.Fog(0x050510, 800, 1500);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        // Камера не имеет начальной позиции, она прикрепится к игроку
        camera.position.set(0, 30, 0); // Высота глаз 30

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 2. ОСВЕЩЕНИЕ и ГРУНТ (Пол) ---
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(200, 500, 300);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const planeGeo = new THREE.PlaneGeometry(2000, 2000);
        const planeMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        const gridHelper = new THREE.GridHelper(2000, 50, 0x00ffff, 0x333333);
        scene.add(gridHelper);

        const playerMeshes = {};
        const bulletMeshes = [];
        let myId = null;

        // --- FPS INPUT ---
        let keys = { w: false, a: false, s: false, d: false };
        let playerAngleYaw = 0; // Угол поворота игрока (глобальная переменная)
        let playerPitch = 0; // Угол наклона головы (для реализма, но не используется в 2D логике сервера)
        const SENSITIVITY = 0.002;

        // Захват курсора при клике
        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === renderer.domElement) {
                // Вращение по горизонтали (Yaw)
                playerAngleYaw -= e.movementX * SENSITIVITY; 
                // Вращение по вертикали (Pitch, не используется для стрельбы в нашей логике, но нужно для вида)
                playerPitch += e.movementY * SENSITIVITY;
                playerPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, playerPitch));
            }
        });
        
        document.addEventListener('mousedown', () => {
            if (document.pointerLockElement === renderer.domElement) {
                socket.emit('shoot');
            }
        });

        window.addEventListener('keydown', e => {
            if(e.key === 'w') keys.w = true;
            if(e.key === 'a') keys.a = true;
            if(e.key === 's') keys.s = true;
            if(e.key === 'd') keys.d = true;
        });

        window.addEventListener('keyup', e => {
            if(e.key === 'w') keys.w = false;
            if(e.key === 'a') keys.a = false;
            if(e.key === 's') keys.s = false;
            if(e.key === 'd') keys.d = false;
        });

        // --- 3D МОДЕЛИ ---
        function createPlayerMesh(color) {
            const group = new THREE.Group();
            
            // Тело
            const bodyGeo = new THREE.CylinderGeometry(10, 10, 30, 16);
            const bodyMat = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 15;
            body.castShadow = true;
            group.add(body);

            // Голова
            const headGeo = new THREE.SphereGeometry(8, 16, 16);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 35;
            group.add(head);

            // Оружие (просто куб перед камерой)
            const gunGeo = new THREE.BoxGeometry(8, 8, 20);
            const gunMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const gun = new THREE.Mesh(gunGeo, gunMat);
            gun.position.set(10, 15, 0); 
            group.add(gun);

            return group;
        }

        // --- СЕТЕВОЕ ОБНОВЛЕНИЕ ---
        socket.on('init', (data) => {
            myId = data.myId;
            data.obstacles.forEach(obs => {
                const geo = new THREE.BoxGeometry(obs.w, 60, obs.h);
                const mat = new THREE.MeshLambertMaterial({ color: 0x0088ff });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(obs.x, 30, obs.y);
                mesh.castShadow = true;
                scene.add(mesh);
            });
        });

        socket.on('state', (state) => {
            // Удаляем/Обновляем игроков
            for (let id in playerMeshes) {
                if (!state.players[id]) {
                    scene.remove(playerMeshes[id]);
                    delete playerMeshes[id];
                }
            }

            for (let id in state.players) {
                const p = state.players[id];
                
                if (!playerMeshes[id]) {
                    playerMeshes[id] = createPlayerMesh(p.color);
                    scene.add(playerMeshes[id]);
                }

                const mesh = playerMeshes[id];
                const targetPos = new THREE.Vector3(p.x, 0, p.y); 
                mesh.position.lerp(targetPos, 0.3);
                mesh.rotation.y = -p.angle + Math.PI / 2;
                
                // --- FPS ЛОГИКА ---
                if (id === myId) {
                    // 1. ПЕРЕМЕЩАЕМ КАМЕРУ НА УРОВЕНЬ ГЛАЗ ИГРОКА
                    camera.position.set(p.x, 30, p.y); // Высота 30
                    
                    // 2. ВРАЩАЕМ КАМЕРУ ПО ГОРИЗОНТАЛИ И ВЕРТИКАЛИ
                    camera.rotation.y = playerAngleYaw;
                    
                    // 3. СКРЫВАЕМ СВОЮ МОДЕЛЬ
                    mesh.visible = false;
                    
                    // 4. Обновляем UI
                    document.getElementById('hp').innerText = Math.ceil(p.hp);
                    document.getElementById('score').innerText = p.score;
                } else {
                    // Другие игроки видимы
                    mesh.visible = true;
                }
            }

            // Пули
            bulletMeshes.forEach(b => scene.remove(b));
            bulletMeshes.length = 0;

            state.bullets.forEach(b => {
                const geo = new THREE.SphereGeometry(3, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(b.x, 20, b.y);
                scene.add(mesh);
                bulletMeshes.push(mesh);
            });
        });

        // --- ОТПРАВКА INPUT ---
        setInterval(() => {
            if (!myId) return;

            // Угол поворота камеры (который управляется мышью) отправляется как угол прицеливания
            socket.emit('input', { ...keys, angle: playerAngleYaw + Math.PI / 2 });
            // +Math.PI / 2 для компенсации стандартного направления вращения Three.js
        }, 1000 / 60);

        // --- РЕНДЕР ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
